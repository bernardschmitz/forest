<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="https://www.google.com/jsapi"></script>
	</head>
	<body>

		<h1>Forest Visibility Simulation</h1>

		<div style="float: left;">
		<form>
			<label for="density">Wood Density</label>
			<input type="text" name="density" id="density" value="0.1"/>
			<br/>
			<label for="radius">Trunk Radius</label>
			<input type="text" name="radius" id="radius" value="5"/>
			<br/>
			<label for="N">Trials</label>
			<input type="text" name="N" id="N" value="100"/>
			<br/>
			<label for="draw">Draw</label>
			<input type="checkbox" name="draw" id="draw" checked="checked"/>
			<br/>
			<input type="button" value="Run Simulation" onClick="run()" />
		</form>

		<p id="results" style="width:400px;"></p>

		<canvas id="myCanvas" width="800" height="600" style="border:1px solid #d3d3d3;">
			Your browser does not support the HTML5 canvas tag.</canvas>
		
		</div>

		<div style="float:right;">

			<div id="seen_chart" style="width: 400px; height: 300px;"></div>
			<div id="not_seen_chart" style="width: 400px; height: 300px;"></div>

		</div>
	
		<script>

			google.load("visualization", "1", {packages:["corechart"]});

			var c = document.getElementById("myCanvas");
			var ctx = c.getContext("2d");



			function makeAABB(x, y, w, h) {

				return {
					x: x, 
					y: y, 
					w: w, 
					h: h,
					containsPoint: function(x, y) {
						return x >= this.x && x < this.x+this.w && 
							y >= this.y && y < this.y+this.h;	
					},
					overlapAABB: function(aabb) {
						return this.containsPoint(aabb.x, aabb.y) ||
							this.containsPoint(aabb.x+aabb.w-1, aabb.y) ||
							this.containsPoint(aabb.x, aabb.y+aabb.h-1) ||
							this.containsPoint(aabb.x+aabb.w-1, aabb.y+aabb.h-1);
					},
					containsAABB: function(aabb) {
						return this.containsPoint(aabb.x, aabb.y) &&
							this.containsPoint(aabb.x+aabb.w-1, aabb.y+aabb.h-1);
					},
					containsCircle: function(circle) {
						return this.containsPoint(circle[0]-circle[2], circle[1]) &&
							this.containsPoint(circle[0], circle[1]-circle[2]) &&
							this.containsPoint(circle[0]+circle[2], circle[1]) &&
							this.containsPoint(circle[0], circle[1]+circle[2]);
					}

				};
			}


			function makeQuadTree(x,y,w,h) {

				return {
					boundary : makeAABB(x,y,w,h),
					children : null,
					data : [],

					insert : function(circle) {
							
						if(!this.boundary.containsCircle(circle))
							return false;

						if(this.data.length < 4) {
							this.data.push(circle);
							return true;
						}

						if(this.children == null)
							this.subdivide();

						if(this.children[0].insert(circle)) return true;
						if(this.children[1].insert(circle)) return true;
						if(this.children[2].insert(circle)) return true;
						if(this.children[3].insert(circle)) return true;

						// if circle not inserted it's probably on a boundary
						this.data.push(circle);
						return true;
					},

					subdivide : function() {

						var x = this.boundary.x;
						var y = this.boundary.y;
						var w = this.boundary.w / 2;
						var h = this.boundary.h / 2;
						
						this.children = [];
						this.children.push(makeQuadTree(x, y, w, h));
						this.children.push(makeQuadTree(x+w, y, w, h));
						this.children.push(makeQuadTree(x, y+h, w, h));
						this.children.push(makeQuadTree(x+w, y+h, w, h));
					}

				};

			}

			function drawQuadTree(tree) {

				ctx.strokeStyle = 'red';
				ctx.strokeRect(tree.boundary.x, tree.boundary.y, tree.boundary.w, tree.boundary.h);

				ctx.fillStyle = getRndColor();
				for(var i=0; i<tree.data.length; i++) {

					ctx.beginPath();
					ctx.arc(tree.data[i][0], tree.data[i][1], tree.data[i][2], 0, 2*Math.PI);
					ctx.fill();

				}

				if(tree.children == null)
					return;

				drawQuadTree(tree.children[0]);
				drawQuadTree(tree.children[1]);
				drawQuadTree(tree.children[2]);
				drawQuadTree(tree.children[3]);
			}


			var tree = makeQuadTree(0, 0, 800, 600);

			var cir = [];

			var K = 1000;

			function go() {
				var circle = [ Math.random()*800, Math.random()*600, 5 ];

				if(!tree.insert(circle)) {
					cir.push(circle);

				}

				ctx.fillStyle = 'white';
				ctx.fillRect(0,0,800,600);

				drawQuadTree(tree);

				for(var i=0; i<cir.length; i++) {
					ctx.strokeStyle = 'green';
					ctx.beginPath();
					ctx.arc(cir[i][0], cir[i][1], cir[i][2], 0, 2*Math.PI);
					ctx.stroke();
				}

				K--;
				if(K>=0)
					setTimeout(go, 10);
			}

			go();




//			q = makeAABB(100, 100, 400, 400);
//			ctx.strokeStyle='black';
//			ctx.strokeRect(100,100,400,400);
//			for(var i=0; i<100; i++) {
//				var circle = [ Math.random()*800, Math.random()*600, 20 ];
//
//				ctx.beginPath();
//				ctx.arc(circle[0], circle[1], circle[2], 0, 2*Math.PI);
//
//				if(q.containsCircle(circle)) {
//					ctx.fillStyle = 'black';
//					ctx.fill();
//				}
//				else {
//					ctx.strokeStyle = 'black';
//					ctx.stroke();
//				}
//			}




			function circleOverlap(c0, c1) {

				var dx = c0[0] - c1[0];
				var dy = c0[1] - c1[1];
				var r  = c0[2] + c1[2];
				var d2 = dx*dx + dy*dy;

				return d2 < r*r;
			}


			function circleOverlapsAnyOtherCircle(circle, circles) {

				for(var i=0; i<circles.length; i++) {

					if(circleOverlap(circle, circles[i]))
						return true;
				}

				return false;
			}

			function placeCircleWithoutOverlap(circles, r, w, h) {

				do {
					var circle = [ Math.random()*w, Math.random()*h, r ];
				}
				while(circleOverlapsAnyOtherCircle(circle, circles));

				return circle;
			}



			function generateForest(woodDensity, radius, w, h) {

				var trees = [];

//				console.log(w*h*woodDensity);

				var k = 0;

				while(k*Math.PI*radius*radius < w*h*woodDensity ) {

					tree = placeCircleWithoutOverlap(trees, radius, w, h);
					trees.push(tree);	

					k++;

//					console.log(trees.length*Math.PI*radius*radius);
				}					

				return trees;
			}

			
			function generatePerson(trees, w, h) {

				return placeCircleWithoutOverlap(trees, 2, w, h);
			}

			function drawPerson(ctx, person, color) {

				ctx.beginPath();
				ctx.arc(person[0], person[1], person[2], 0, 2*Math.PI);
				ctx.fillStyle = color;
				ctx.fill();
			}

			function drawTrees(ctx, trees, color) {

				for(var i=0; i<trees.length; i++) {
					//ctx.moveTo(trees[i][0], trees[i][1]);
					ctx.beginPath();
					ctx.arc(trees[i][0], trees[i][1], trees[i][2], 0, 2*Math.PI);
					ctx.strokeStyle = color;
					ctx.stroke();
				}

			}

			function drawSightLine(ctx, from, to, color) {
				ctx.beginPath();
				ctx.strokeStyle = color;
				ctx.moveTo(from[0], from[1]);
				ctx.lineTo(to[0], to[1]);
				ctx.stroke();
			}

			function distance(from, to) {

				var dx = to[0] - from[0];
				var dy = to[1] - from[1];

				return Math.sqrt(dx*dx+dy*dy);
			}

			function distancePointLine(point, from, to) {

				var dx = to[0] - from[0];
				var dy = to[1] - from[1];

				var d = Math.sqrt(dx*dx+dy*dy);

				return Math.abs(dy*point[0] - dx*point[1] + to[0]*from[1] - to[1]*from[0]) / d;
				
			}


			function canSee(from, to, trees) {

				var left = Math.min(from[0], to[0]);
				var right = Math.max(from[0], to[0]);
				var top = Math.min(from[1], to[1]);
				var bottom = Math.max(from[1], to[1]);

				//console.log(from, to, left, right, top, bottom);

				for(var i=0; i<trees.length; i++) {

					var p = trees[i]
					var r = p[2];

					//console.log(p);

					if(p[0] >= left-r && p[0] <= right+r && p[1] >= top-r && p[1] <= bottom+r) {

						var d = distancePointLine(p, from, to); 
						//console.log(d);
						if(d < trees[i][2]) {
							return false;
						}
					}
				}

				return true;
			}


			function runOneTest(draw, density, radius, ctx, width, height) {

				var forest = generateForest(density, radius, width, height);
				var personA = generatePerson(forest, width, height);
				var personB = generatePerson(forest, width, height);
				var see = canSee(personA, personB, forest);

				if(draw) {
					ctx.fillStyle = 'white';
					ctx.fillRect(0,0,width,height);

					drawTrees(ctx, forest, 'black');	
					drawPerson(ctx, personA, 'blue');
					drawPerson(ctx, personB, 'green');

					if(see)
						drawSightLine(ctx, personA, personB, 'green');
					else
						drawSightLine(ctx, personA, personB, 'red');
				}



				return [see, distance(personA, personB)];
			}



			function runSightTests(draw, N, density, radius, ctx, width, height, done) {

				var results = [];

				var tests = N;

				var runTests = function() {

					tests--;

					if(tests >= 0) {
						results.push(runOneTest(draw, density, radius, ctx, width, height));
						setTimeout(runTests, 0);
					}
					else {
						done(results);
					}
				};


				if(draw)
					runTests();
				else {

					for(var i=0; i<N; i++) {
						results.push(runOneTest(draw, density, radius, ctx, width, height));
					}

					done(results);
				}
			}


			function drawHistogram(data) {

				var qq1 = [['Distance']];
				var qq2 = [['Distance']];

				for(var i=0; i<data.length; i++) {
					if(data[i][0]) 
						qq1.push([data[i][1]]);
					else
						qq2.push([data[i][1]]);

				}

				var q = google.visualization.arrayToDataTable(qq1);
				var chart1 = new google.visualization.Histogram(document.getElementById('seen_chart'));
				chart1.draw(q, { title: 'Seen', legend : { position: 'none'} });


				var q2= google.visualization.arrayToDataTable(qq2);
				var chart2 = new google.visualization.Histogram(document.getElementById('not_seen_chart'));
				chart2.draw(q2, { title: 'Not Seen', legend : { position: 'none'} });

			}


			function displayResults(N, results) {

				var seen = 0;
				for(var i=0; i<results.length; i++) {
					if(results[i][0]) {
						seen++;
					}
				}

				var percent = seen*100/N;

				console.log(seen, N, percent);	

				var r = document.getElementById('results');
				r.innerHTML = 'Friend seen '+percent.toPrecision(3)+'%';


				drawHistogram(results);	
			}


			function run() {

				console.log('run');

				var density = parseFloat(document.getElementById('density').value);
				var radius = parseInt(document.getElementById('radius').value);
				var N = parseInt(document.getElementById('N').value);
				var draw = document.getElementById('draw').checked;

				var r = document.getElementById('results');
				r.innerHTML = 'Friend seen --.-%';

				var width = 800;
				var height = 600;

				console.log(density, radius, N, draw, width, height);

				//runSightTests(draw, N, density, radius, ctx, width, height, 
			//		function(results) { displayResults(N, results); });

				runOneTest(draw, density, radius, ctx, width, height);

				var forest = generateForest(density, radius, width, height);
				ctx.fillStyle = 'white';
				ctx.fillRect(0,0,width,height);

				drawTrees(ctx, forest, 'black');


			}

			function getRndColor() {
			    var r = 255*Math.random()|0,
			        g = 255*Math.random()|0,
			        b = 255*Math.random()|0;
			    return 'rgb(' + r + ',' + g + ',' + b + ')';
			}

		</script> 

	</body>
</html>
